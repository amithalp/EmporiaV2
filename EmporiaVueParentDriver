/* Todo list
* none for now
/*****************************************************************************************************************
 *  Raw Source: https://github.com/amithalp/EmporiaV2
 *  License:
 *   Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *   in compliance with the License. You may obtain a copy of the License at:
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *   on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *   for the specific language governing permissions and limitations under the License.
 *
 *   Modifcation History
 *   Date           Name            Change
 *   2025-01-13     amithalp        version 1.0.0 - Initial public release
 *   2026-01-19     amithalp        version 1.1.0 - Clarify refreshData logging (refreshes single deviceGid), add refreshAllDevices() helper.
 *   2026-01-19     amithalp        version 1.1.1 - Add version() helper + metadata version, safer gid parsing, fix "lastUpdate" attr naming consistency, add setRetrievalFrequency().
 *****************************************************************************************************************
 * EmporiaVueParentDriver
 *
 * This driver acts as the parent device for Emporia Vue integrations.
 * - Manages child devices corresponding to monitored circuits.
 * - Supports refreshing data and updating child devices via the parent app.
 * - Fetches and stores location-related attributes.
 *
 * Author: Amit Halperin
 */

import groovy.json.*

static String version() { return "1.1.1" }

metadata {
    definition(
        name: "EmporiaVueParentDriver",
        namespace: "amithalp",
        author: "Amit Halperin",
        importUrl: ""
    ) {
        capability "Refresh"
        capability "PowerMeter"
        capability "EnergyMeter"

        command "fetchLocationData"
        command "fetchDeviceData"
        command "refreshAllDevices"

        attribute "locationDeviceName", "string"
        attribute "locationZipCode", "string"
        attribute "locationTimeZone", "string"
        attribute "billingCycleStartDay", "number"
        attribute "usageCentPerKwHour", "number"
        attribute "peakDemandDollarPerKw", "number"
        attribute "utilityRateGid", "string"
        attribute "latitude", "number"
        attribute "longitude", "number"
        attribute "locationAirConditioning", "string"
        attribute "locationHeatSource", "string"
        attribute "locationSqFt", "string"
        attribute "locationType", "string"
        attribute "locationNumElectricCars", "number"
        attribute "locationNumPeople", "number"
        attribute "locationSwimmingPool", "string"

        // FIX: your code uses "lastUpdate" event name, so keep attribute as lastUpdate (not lastUpdateD)
        attribute "lastUpdate", "string"

        attribute "energyUnit", "string"
        attribute "retrievalFrequency", "string"
        attribute "driverVersion", "string"
    }
}

preferences {
    input name: "logEnable", type: "bool", title: "Enable Debug Logging", defaultValue: true
    input name: "jsonState", type: "bool", title: "Show JSON state", defaultValue: false
}

def installed() {
    log.info "EmporiaVueParentDriver installed for device ${device.displayName}"
    initialize()
    fetchLocationData()
}

def updated() {
    log.info "EmporiaVueParentDriver updated for device ${device.displayName}"
    initialize()
    fetchLocationData()
}

def initialize() {
    sendEvent(name: "driverVersion", value: version())

    if (logEnable) {
        log.debug "Initializing EmporiaVueParentDriver v${version()} for ${device.displayName}"
        runIn(1800, toggleDebugLogging)
    }
    state.lastUpdate = null
}

def toggleDebugLogging() {
    log.warn "Disabling debug logging for ${device.displayName} after 30 minutes."
    device.updateSetting("logEnable", [value: "false", type: "bool"])
}

def refresh() {
    if (logEnable) log.debug "Refreshing data for ${device.displayName}"
    fetchDeviceData()
}

/**
 * Helper to extract numeric Emporia deviceGid from deviceNetworkId
 * Expected DNI: EmporiaVue<deviceGid>
 */
private String getThisDeviceGid() {
    def dni = device?.deviceNetworkId?.toString() ?: ""
    return dni.startsWith("EmporiaVue") ? dni.substring("EmporiaVue".length()) : dni
}

/**
 * Called from child devices: parent?.refreshData()
 * Always refresh THIS parent’s numeric deviceGid unless an explicit one is passed.
 */
def refreshData(deviceGid = null) {
    def gid = (deviceGid != null) ? deviceGid.toString() : getThisDeviceGid()
    log.info "Refreshing data for deviceGid: ${gid}"

    try {
        if (parent && parent.metaClass?.respondsTo(parent, 'fetchData')) {
            parent.fetchData(gid)   // refresh a single device deterministically
        } else {
            log.warn "Parent app.fetchData() not available; cannot perform refresh."
        }
    } catch (e) {
        log.error "Error during refreshData for deviceGid ${gid}: ${e}"
    }
}

/**
 * Optional helper: refresh all monitored devices
 * Safe if the app’s fetchData(null) uses numeric GIDs list.
 */
def refreshAllDevices() {
    log.info "Requesting full refresh of all monitored devices via app.fetchData()"
    try {
        if (parent && parent.metaClass?.respondsTo(parent, 'fetchData')) {
            parent.fetchData()
        } else {
            log.warn "Parent app.fetchData() not available; cannot perform full refresh."
        }
    } catch (e) {
        log.error "Error while requesting full refresh of all devices: ${e}"
    }
}

def fetchDeviceData() {
    if (!parent) {
        log.error "Parent app not found. Unable to fetch device data."
        return
    }

    def deviceGid = getThisDeviceGid()
    if (logEnable) log.debug "Requesting data fetch for device GID: ${deviceGid}"
    parent.fetchData(deviceGid)
}

def fetchLocationData() {
    if (!parent || !parent.hasProperty('state')) {
        log.error "Parent app state is not available. Unable to fetch location data."
        return
    }

    def token = parent?.state?.idToken
    if (!token) {
        log.error "Authentication token is missing. Unable to fetch location data."
        return
    }

    def deviceGid = getThisDeviceGid()
    def host = "https://api.emporiaenergy.com/"
    def command = "devices/${deviceGid}/locationProperties"

    def params = [
        uri: "${host}${command}",
        headers: ['authtoken': token]
    ]

    try {
        httpGet(params) { resp ->
            if (resp.status == 200) {
                def locationData = resp.data
                if (logEnable) log.debug "Fetched location data for ${deviceGid}"

                sendEvent(name: "locationDeviceName", value: locationData.deviceName ?: "Unknown")
                sendEvent(name: "locationZipCode", value: locationData.zipCode ?: "Unknown")
                sendEvent(name: "locationTimeZone", value: locationData.timeZone ?: "Unknown")
                sendEvent(name: "billingCycleStartDay", value: locationData.billingCycleStartDay ?: 0)
                sendEvent(name: "usageCentPerKwHour", value: locationData.usageCentPerKwHour ?: 0)
                sendEvent(name: "peakDemandDollarPerKw", value: locationData.peakDemandDollarPerKw ?: 0)
                sendEvent(name: "utilityRateGid", value: locationData.utilityRateGid ?: "Unknown")
                sendEvent(name: "latitude", value: locationData.latitudeLongitude?.latitude ?: 0)
                sendEvent(name: "longitude", value: locationData.latitudeLongitude?.longitude ?: 0)
                sendEvent(name: "locationAirConditioning", value: locationData.locationInformation?.airConditioning ?: "Unknown")
                sendEvent(name: "locationHeatSource", value: locationData.locationInformation?.heatSource ?: "Unknown")
                sendEvent(name: "locationSqFt", value: locationData.locationInformation?.locationSqFt ?: "Unknown")
                sendEvent(name: "locationType", value: locationData.locationInformation?.locationType ?: "Unknown")
                sendEvent(name: "locationNumElectricCars", value: (locationData.locationInformation?.numElectricCars ?: 0).toInteger())
                sendEvent(name: "locationNumPeople", value: (locationData.locationInformation?.numPeople ?: 0).toInteger())
                sendEvent(name: "locationSwimmingPool", value: locationData.locationInformation?.swimmingPool ?: "Unknown")

                state.lastUpdate = new Date().format("yyyy-MM-dd'T'HH:mm:ss'Z'")
                sendEvent(name: "lastUpdate", value: state.lastUpdate)

                log.info "Location data successfully updated for deviceGid ${deviceGid}"
            } else {
                log.error "Error fetching location data. HTTP status: ${resp.status}"
            }
        }
    } catch (e) {
        log.error "Error fetching location data: ${e.message}"
    }
}

def setEnergyUnit(String unit) {
    if (logEnable) log.debug "Setting energy unit to ${unit} for ${device.displayName}"

    def validUnits = ["KilowattHours", "Dollars"]
    if (!validUnits.contains(unit)) {
        log.error "Invalid energy unit: ${unit}. Supported units are: ${validUnits.join(', ')}"
        return
    }

    state.energyUnit = unit
    sendEvent(name: "energyUnit", value: unit)
    if (logEnable) log.info "Energy unit set to ${unit} for ${device.displayName}"
}

def setRetrievalFrequency(String freq) {
    if (freq == null) return
    state.retrievalFrequency = freq
    sendEvent(name: "retrievalFrequency", value: freq)
    if (logEnable) log.debug "Retrieval frequency set to ${freq} for ${device.displayName}"
}
